<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>Eye Follows You – Single</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <link rel="manifest" href="/manifest.webmanifest">
  <style>
    html, body { margin:0; height:100%; background:#000; }
    body {
      padding-top: env(safe-area-inset-top);
      padding-bottom: env(safe-area-inset-bottom);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
    }
    canvas { display:block; width:100vw; height:100vh; }
    video { position:fixed; right:0; bottom:0; width:1px; height:1px; opacity:0; pointer-events:none; }
    .hint {
      position: fixed; left: 12px; bottom: 12px; color:#888; font: 12px/1.3 system-ui, sans-serif;
      background: rgba(0,0,0,.5); padding:6px 8px; border-radius:6px;
    }
    .fs-btn{
      position: fixed; right: 12px; bottom: 12px;
      width: 40px; height: 40px; border: 0; border-radius: 8px;
      background: rgba(255,255,255,0.1); color:#ddd; font-size:18px;
      backdrop-filter: blur(4px); cursor: pointer;
    }
    .fs-btn:active{ transform: scale(0.98); }
  </style>
</head>
<body>
  <canvas id="stage"></canvas>
  <video id="webcam" autoplay playsinline></video>
  <div class="hint">카메라 권한을 허용하세요. 사람이 없으면 중앙을 보다가, 나타나면 시선을 따라갑니다.</div>
  <button id="fsBtn" class="fs-btn" aria-label="전체화면 전환">⤢</button>

  <script type="module">
    import { FaceLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.mjs";

    // ====== 깜빡임/모양 파라미터 ======
    const BLINK_MIN = 1000;      // ms
    const BLINK_MAX = 7000;      // ms
    const BLINK_DURATION = 220;  // 닫힘→열림 총 시간(ms)

    const eyeScale = 4;              // 눈 크기 배수
    const pupilEdgePadding = 0.15;   // 동공이 흰자 밖으로 나가지 않게 여유

    // 외곽 형태(마름모+라운드)
    const eyeWidthFactor  = 1.95;    // 가로 폭
    const eyeHeightFactor = 1.02;    // 세로 폭
    const cornerRound     = 0.9;     // 꼭짓점 둥근 정도(0~1; 값이 클수록 많이 둥글)
    const edgeBulge       = 0;       // 변의 볼록함(0=직선, 0.1~0.18 권장)

    // ====== 캔버스 ======
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const canvas = document.getElementById('stage');
    const ctx = canvas.getContext('2d', { alpha:false });
    const video = document.getElementById('webcam');

    function resize() {
      const w = Math.floor(window.innerWidth * dpr);
      const h = Math.floor(window.innerHeight * dpr);
      canvas.width = w; canvas.height = h;
      canvas.style.width = window.innerWidth + 'px';
      canvas.style.height = window.innerHeight + 'px';
    }
    window.addEventListener('resize', resize);
    resize();

    // ====== 상태 ======
    const state = {
      eyeGapFactor: 0.3,      // (단일 눈에선 사용 안 하지만 값 유지)
      eyeballRFactor: 0.12,
      pupilRFactor: 0.050,
      targetX: 0, targetY: 0,
      smoothedX: 0, smoothedY: 0, // EMA
      hasFace: false,
      nextBlinkAt: 0,
      blinking: false,
      blinkStart: 0
    };

    // ====== 카메라 & 미러 판정 ======
    let mirrorX = true;
    async function initCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "user", width: {ideal: 1280}, height: {ideal: 720} },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      const track = stream.getVideoTracks()[0];
      const settings = track?.getSettings?.() || {};
      mirrorX = (settings.facingMode || "user") !== "environment";
    }

    // ====== MediaPipe ======
    let faceLandmarker;
    async function initFaceLandmarker() {
      const filesetResolver = await FilesetResolver.forVisionTasks(
        "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
      );
      faceLandmarker = await FaceLandmarker.createFromOptions(filesetResolver, {
        baseOptions: {
          modelAssetPath:
            "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task"
        },
        runningMode: "VIDEO",
        numFaces: 5,
        minFaceDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
    }

    // ====== 유틸 ======
    function pickClosestFace(faces) {
      if (!faces || faces.length === 0) return null;
      let best = null, bestScore = -1;
      for (const lm of faces) {
        let minX=1, minY=1, maxX=0, maxY=0;
        for (const p of lm) {
          if (p.x < minX) minX = p.x;
          if (p.x > maxX) maxX = p.x;
          if (p.y < minY) minY = p.y;
          if (p.y > maxY) maxY = p.y;
        }
        const area = (maxX - minX) * (maxY - minY);
        if (area > bestScore) { bestScore = area; best = lm; }
      }
      return best;
    }
    function meanPoint(lm) {
      let sx=0, sy=0;
      for (const p of lm) { sx += p.x; sy += p.y; }
      const n = lm.length || 1;
      return { x: sx/n, y: sy/n };
    }
    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    // ====== 둥근 마름모 경로 ======
    function roundedDiamondPath(ctx, cx, cy, rx, ry, corner=0.08, bulge=0.12) {
      const T = [cx, cy - ry], R = [cx + rx, cy], B = [cx, cy + ry], L = [cx - rx, cy];
      const l = corner * Math.min(rx, ry);
      const mv = (a, b, d) => { const vx=b[0]-a[0], vy=b[1]-a[1], len=Math.hypot(vx,vy)||1, t=d/len; return [a[0]+vx*t, a[1]+vy*t]; };
      const mid = (a,b)=>[(a[0]+b[0])/2,(a[1]+b[1])/2];
      const bulgeCtrl = (a,b,center,amt)=>{ const m=mid(a,b); const nx=m[0]-center[0], ny=m[1]-center[1]; const nlen=Math.hypot(nx,ny)||1; const k=(amt*Math.min(rx,ry))/nlen; return [m[0]+nx*k, m[1]+ny*k]; };

      const TR1=mv(T,R,l), RT1=mv(R,T,l);
      const RB1=mv(R,B,l), BR1=mv(B,R,l);
      const BL1=mv(B,L,l), LB1=mv(L,B,l);
      const LT1=mv(L,T,l), TL1=mv(T,L,l);

      const C_TR = bulgeCtrl(TR1,RT1,[cx,cy],bulge);
      const C_RB = bulgeCtrl(RB1,BR1,[cx,cy],bulge);
      const C_BL = bulgeCtrl(BL1,LB1,[cx,cy],bulge);
      const C_LT = bulgeCtrl(LT1,TL1,[cx,cy],bulge);

      ctx.beginPath();
      ctx.moveTo(...TR1); ctx.quadraticCurveTo(...C_TR, ...RT1);
      ctx.quadraticCurveTo(...R, ...RB1);
      ctx.quadraticCurveTo(...C_RB, ...BR1);
      ctx.quadraticCurveTo(...B, ...BL1);
      ctx.quadraticCurveTo(...C_BL, ...LB1);
      ctx.quadraticCurveTo(...L, ...LT1);
      ctx.quadraticCurveTo(...C_LT, ...TL1);
      ctx.quadraticCurveTo(...T, ...TR1);
    }

    // ====== 드로잉 ======
    function drawEye() {
      const w = canvas.width, h = canvas.height;
      const minDim = Math.min(w, h);
      const cx = w * 0.5, cy = h * 0.5;

      // 크기 계산(단일 눈: 가용 영역 기준)
      const R_want = minDim * state.eyeballRFactor * eyeScale;
      const marginW = w * 0.06;
      const marginH = Math.max(h * 0.12, 20);
      const maxR_byWidth  = (w - marginW*2) * 0.5;
      const maxR_byHeight = (h - marginH*2) * 0.5;
      const eyeballR = Math.min(R_want, maxR_byWidth, maxR_byHeight);

      const pupilRatio = state.pupilRFactor / state.eyeballRFactor;
      const pupilR = eyeballR * pupilRatio;

      // 타깃 스무딩
      const alpha = 0.2;
      state.smoothedX += alpha * (state.targetX - state.smoothedX);
      state.smoothedY += alpha * (state.targetY - state.smoothedY);

      // 전역 오프셋(동공)
      let gdx = state.smoothedX - cx;
      let gdy = state.smoothedY - cy;
      const maxOffset = eyeballR - pupilR - (eyeballR * pupilEdgePadding);
      const glen = Math.hypot(gdx, gdy) || 1;
      if (glen > maxOffset) { const k = maxOffset / glen; gdx *= k; gdy *= k; }

      const pupil = { x: cx + gdx, y: cy + gdy };

      // 깜빡임
      const now = performance.now();
      if (!state.nextBlinkAt) state.nextBlinkAt = now + randInt(BLINK_MIN, BLINK_MAX);
      if (!state.blinking && now >= state.nextBlinkAt) { state.blinking = true; state.blinkStart = now; }
      let blinkAmt = 0;
      if (state.blinking) {
        const p = Math.min(1, (now - state.blinkStart) / BLINK_DURATION);
        blinkAmt = p < 0.5 ? (p*2) : (1-p)*2;
        if (p >= 1) { state.blinking = false; state.nextBlinkAt = now + randInt(BLINK_MIN, BLINK_MAX); blinkAmt = 0; }
      }
      const minOpen = 0.08;
      const openScale = Math.max(minOpen, 1 - blinkAmt);

      // 외곽(마름모 반경)
      const rx = eyeballR * eyeWidthFactor;
      const ry = eyeballR * eyeHeightFactor * openScale;

      // === 렌더 ===
      ctx.fillStyle = "#000"; ctx.fillRect(0,0,w,h);

      // 흰자
      ctx.fillStyle = "#fff";
      roundedDiamondPath(ctx, cx, cy, rx, ry, cornerRound, edgeBulge);
      ctx.fill();

      // 클립 후 동공
      ctx.save();
      roundedDiamondPath(ctx, cx, cy, rx, ry, cornerRound, edgeBulge);
      ctx.clip();
      ctx.fillStyle = "#000";
      ctx.beginPath();
      ctx.arc(pupil.x, pupil.y, pupilR, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    // ====== 루프 ======
    let lastVideoTime = -1;
    function loop() {
      requestAnimationFrame(loop);
      if (!faceLandmarker || video.readyState < 2) { drawEye(); return; }

      const now = performance.now();
      const vTime = video.currentTime;
      if (vTime === lastVideoTime) { drawEye(); return; }
      lastVideoTime = vTime;

      const results = faceLandmarker.detectForVideo(video, now);
      const faces = results?.faceLandmarks || [];
      const closest = pickClosestFace(faces);

      if (closest) {
        const m = meanPoint(closest);
        const mx = mirrorX ? (1 - m.x) : m.x;

        const cx = canvas.width * 0.5;
        const cy = canvas.height * 0.5;
        const minDim = Math.min(canvas.width, canvas.height);
        const gazeRange = minDim * 0.5;

        const offX = (mx - 0.5) * gazeRange;
        const offY = (m.y - 0.5) * gazeRange;

        state.targetX = cx + offX;
        state.targetY = cy + offY;
        state.hasFace = true;
      } else {
        state.targetX = canvas.width * 0.5;
        state.targetY = canvas.height * 0.5;
        state.hasFace = false;
      }

      drawEye();
    }

    // ====== 실행 ======
    (async () => {
      try {
        await initCamera();
        await initFaceLandmarker();
        state.targetX = canvas.width * 0.5;
        state.targetY = canvas.height * 0.5;
        state.smoothedX = state.targetX;
        state.smoothedY = state.targetY;
        loop();
      } catch (err) {
        console.error(err);
        alert("초기화 실패: " + (err?.message || err));
      }
    })();

    // ====== 전체화면 토글 ======
    function isFullscreen() {
      return document.fullscreenElement || document.webkitFullscreenElement;
    }
    async function enterFullscreen(el = document.documentElement) {
      try {
        if (el.requestFullscreen) await el.requestFullscreen();
        else if (el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
      } catch (e) { console.warn('enter FS fail:', e); }
    }
    async function exitFullscreen() {
      try {
        if (document.exitFullscreen) await document.exitFullscreen();
        else if (document.webkitExitFullscreen) await document.webkitExitFullscreen();
      } catch (e) { console.warn('exit FS fail:', e); }
    }
    async function toggleFullscreen() {
      if (isFullscreen()) await exitFullscreen();
      else await enterFullscreen(document.documentElement);
    }
    document.getElementById('fsBtn')?.addEventListener('click', toggleFullscreen);

    // 더블탭 토글
    let lastTap = 0;
    canvas.addEventListener('pointerdown', () => {
      const now = performance.now();
      if (now - lastTap < 300) toggleFullscreen();
      lastTap = now;
    });
  </script>
</body>
</html>
